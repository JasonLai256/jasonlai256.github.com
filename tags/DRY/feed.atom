<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Recent Blog Posts</title>
  <id>http://www.pywave.com/feed.atom</id>
  <updated>2012-07-23T00:00:00Z</updated>
  <link href="http://www.pywave.com/" />
  <link href="http://www.pywave.com/feed.atom" rel="self" />
  <subtitle type="text">Recent blog posts</subtitle>
  <generator>Werkzeug</generator>
  <entry xml:base="http://www.pywave.com/feed.atom">
    <title type="text">Hello Modularity</title>
    <id>http://www.pywave.com/2012/07/23/hello-modularity</id>
    <updated>2012-07-23T00:00:00Z</updated>
    <link href="http://www.pywave.com/2012/07/23/hello-modularity" />
    <author>
      <name>Jason Lai</name>
    </author>
    <content type="html">&lt;p&gt;现代的程序设计是越来越复杂，为了掌控其中不断增长的复杂度，以及可能随时到来的需求变化，模块化设
计是最重要的手段之一。学习编程以来，对模块化的理解随着知识经验的增加而不断变化。到现在，恍然意
识到，人类社会的每一个重大进步和发展无不是 &lt;strong&gt;站在巨人的肩膀上&lt;/strong&gt; ，雄伟的金字塔由众多规格统一的石
头砌成，现代的集成电路基于基本的逻辑门和触发器，大规模的程序实现离不开结构化程序设计以及各式
功能模块支持。大道至简，模块化的思想并不局限于程序设计，是如此简单，也是如此繁复。&lt;/p&gt;
&lt;p&gt;每当程序复杂度增长到一定程度时，总能感悟到模块化编程的重要性，在 The Art of Unix Programming
中对于模块化有着直接了当的说明：&lt;/p&gt;
&lt;p&gt;The only way to write complex software that won't fall on its face is to build
it out of simple modules connected by well-defined interfacs, so that most
problems are local and you can have some hope of fixing or optimizing a part
without breaking the whole.&lt;/p&gt;
&lt;p&gt;还记得初始编程那会，在古董级的 Turbo C 3.0 上照着书操弄着初始的 C语言，什么都不懂，是如此的质朴。
但人是会进步的，在数次痛苦经历的洗礼，以及多本经典的好书 &lt;a class="footnote-reference" href="#id3" id="id1"&gt;[1]&lt;/a&gt; 的指导下，逐渐意识到，要想在跟复杂
度和需求变化的战斗中不至于一败涂地，必须尽量保持模块间的正交性，紧密耦合的模块将导致修改局部而牵
动全局的后果；还要做好模块的信息隐藏，包括对于复杂和易变部分的封装，以及定义良好的模块接口；应使用
薄胶合层来组织程序中的不同模块和层次，厚重的胶合层必然会带来额外的逻辑处理以及复杂度；不能忘了，
要让事情尽可能的简单，但不能过于简单。&lt;/p&gt;
&lt;p&gt;程序设计是一种高挑战性的游戏，接触不久就牢牢捕获了我的心，这些年来，除了收获到许多难以言喻的快乐外，
我的人生观和价值观都得到了深刻的改变。自由的信息获取观念，理性的对待问题，追寻简单的艺术和美，这就
是我现在的所有。模块化不仅是编程的概念，生活中依然适用。&lt;/p&gt;
&lt;p&gt;围绕着模块化，立即就联想到了 KISS 原则和 DRY 原则，两者都是在心中周而复始的小声音，就像是旅途中的指南
针，指引着自己不断前行。&lt;/p&gt;
&lt;div class="section" id="kiss"&gt;
&lt;h2&gt;&lt;a class="reference external" href="http://en.wikipedia.org/wiki/KISS_principle"&gt;KISS原则&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对于 UNIX 哲学，一言以蔽之，Keep It Simple, Stupid!&lt;/p&gt;
&lt;p&gt;简单可行的设计永远都是好的设计，复杂的设计意味着更难以应对变化。&lt;/p&gt;
&lt;p&gt;小时候，自己总是认为，唯有对事情有了完全的掌握后才能将事情完美的做好。同时，有那么一种倾向，必须作
出最好的决策，以最专注的态度去实现，然后就能得出最好的结果。&lt;/p&gt;
&lt;p&gt;上面的想法看起来很美好。但是现实告诉我们，这是最没有实效的方法之一。我们必须明白，在这世界上，任何
有意义的事情，都不存在一蹴而就和一劳永逸。事物总是处于变化与稳定的临界状态中，彼此维持于一种微妙的
动态平衡，经外来或内部因素的稍一“搅拌”，各种未知状态便会涌向，趋向于混沌。简而言之，事情总是会变化
的，不论你想还是不想，有所准备还是匆忙应付。&lt;/p&gt;
&lt;p&gt;为了应对变化，我们必须更为灵活。在我看来，这就是 KISS 原则最重要的含义。&lt;/p&gt;
&lt;p&gt;而模块化的设计，正是 KISS 原则的最佳体现和实践。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dry"&gt;
&lt;h2&gt;&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"&gt;DRY原则&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;重复是有害的。&lt;/p&gt;
&lt;p&gt;最简单地来看，重复消耗更多的时间，而时间实质上就是一切。&lt;/p&gt;
&lt;p&gt;在良好的模块化设计里，DRY 原则必然是被遵守的准则之一。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;写在最后&lt;/h2&gt;
&lt;p&gt;模块化设计在现代的结构化编程里是如此的普遍，每个人对于模块化都有不同的认识。我不认为自己对于模块化
有多么深刻的了解，但在喜爱上编程的这些时间里，确实对模块化有了点点滴滴的感悟，于是写下了自己对于
模块化的一些认知。这是此 Blog 里的第一篇文章，基于程序员世界 &amp;quot;Hello World&amp;quot; 的习惯，故将此文
命名为 &amp;quot;Hello Modulatity&amp;quot;。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="id3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;毫不犹豫地推荐《代码大全》、《程序员修炼之道》、《UNIX编程艺术》和《重构》等极品好书。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content>
  </entry>
</feed>

